// Generated by CoffeeScript 1.6.3
(function() {
  var ambi, typeChecker,
    __slice = [].slice;

  typeChecker = require('typechecker');

  ambi = function() {
    var acceptedArgumentsLength, args, argumentsDifferenceLength, completionCallback, err, executeAsynchronously, fireMethod, givenArgumentsLength, introspectMethod, method, result, simpleArguments, _i;
    method = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    if (typeChecker.isArray(method)) {
      fireMethod = method[0], introspectMethod = method[1];
    } else {
      fireMethod = introspectMethod = method;
    }
    simpleArguments = 2 <= args.length ? __slice.call(args, 0, _i = args.length - 1) : (_i = 0, []), completionCallback = args[_i++];
    if (!typeChecker.isFunction(completionCallback)) {
      err = new Error('ambi was called without a completion callback');
      throw err;
    }
    /*
    	Different ways functions can be called:
    	ambi(function(a,next){return next()}, a, next)
    		> VALID: execute asynchronously
    		> given arguments are SAME as the accepted arguments
    		> method will be fired with (a, next)
    	ambi(function(a,next){return next()}, next)
    		> VALID: execute asynchronously
    		> given arguments are LESS than the accepted arguments
    		> method will be fired with (undefined, next)
    	ambi(function(a){}, a, next)
    		> VALID: execute synchronously
    		> given arguments are MORE than expected arguments
    		> method will be fired with (a)
    	ambi(function(a){}, next)
    		> INVALID: execute asynchronously
    		> given arguments are SAME as the accepted arguments
    		> method will be fired with (next)
    		> if they want to use optional args, the function must accept a completion callback
    */

    givenArgumentsLength = args.length;
    acceptedArgumentsLength = introspectMethod.length;
    if (givenArgumentsLength === acceptedArgumentsLength) {
      executeAsynchronously = true;
    } else if (givenArgumentsLength < acceptedArgumentsLength) {
      executeAsynchronously = true;
      argumentsDifferenceLength = acceptedArgumentsLength - givenArgumentsLength;
      args = simpleArguments.slice().concat(new Array(argumentsDifferenceLength)).concat([completionCallback]);
    } else {
      executeAsynchronously = false;
      args = simpleArguments.slice();
    }
    if (executeAsynchronously) {
      fireMethod.apply(null, args);
    } else {
      result = fireMethod.apply(null, args);
      if (typeChecker.isError(result)) {
        err = result;
        completionCallback(err);
      } else {
        completionCallback(null, result);
      }
    }
    return null;
  };

  module.exports = ambi;

}).call(this);
